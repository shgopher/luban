<!--
 * @Author: shgopher shgopher@gmail.com
 * @Date: 2025-05-20 23:25:27
 * @LastEditors: shgopher shgopher@gmail.com
 * @LastEditTime: 2025-07-20 09:58:48
 * @FilePath: /luban/系统设计基础/分布式/分布式组件/分布式锁/README.md
 * @Description: 
 * 
 * Copyright (c) 2025 by shgopher, All Rights Reserved. 
-->
# 分布式锁

- 基于数据库实现的分布式锁
- 基于缓存实现的分布式锁
- 基于 zookeeper 实现的分布式锁


基于数据库做的分布式锁原理也很简单，数据库本身会有锁的机制，创建一张锁表，为申请者在锁表里建立一条记录，记录建立成功则获得锁，消除记录则释放锁。

缺点吗？就是数据库的效率并不高，并且容易产生单点故障以及死锁的问题，如果在一个小项目或者 io 特别低的项目，这种方案完全没有问题。

使用缓存作为分布式锁，因为缓存放置在内存中所以无需磁盘的 io 问题，效率会非常的高，Redis 通常可以使用 setnx(key，value) 函数来实现分布式锁，其中 key 表示锁 id，value = currentTime + timeOut，表示当前时间 + 超时时间，超过超时时间则锁自动释放，setnx 返回 01 0 表示获取锁失败，1 表示获取锁成功。当0时可以设置一定的重试时间间隔，再次尝试获取锁，当1时则直接返回成功。

值得一提的是，redis 去实现的分布式锁实现了等待队列的方案，如果未获得锁，则将当前线程加入到等待队列中，当锁释放时，等待队列中的线程会重新尝试获取锁，顺序执行。

redis 等缓存去充当分布式锁的时候，优点在于，性能高，可以跨集群部署，核心就是不同的集群部署相同的数据，然后数据自动同步。

通过 redis 等缓存去实现的分布式锁最不靠谱的地方在于，通过超时时间去释放锁，万一没有执行完成就释放了锁呢？

zookeeper 使用树形结构去实现分布式锁，zk 的树形结构主要有四种，分别是持久节点，这也是 zk 的模式结构，持久顺序节点，根据创建的时间去节点自动进行排序，临时节点，当客户端与 ZooKeeper 断开连接后，该进程创建的临时节点就会被删除。临时顺序节点，而使用 zk 去实现分布式锁是使用的最后一种结构---临时顺序节点

实现锁的方法：
1。创建一个持久节点，并设置其值为锁的标识符。在与该方法对应的持久节点的目录下，为每个进程创建一个临时顺序节点。
2。每个进程获取所有临时节点列表，对比自己的编号是否最小，若最小，则获得锁。
3。若本进程对应的临时节点编号不是最小的，则继续判断：
若本进程为读请求，则向比自己序号小的最后一个写请求节点注册 watch 监听，当
监听到该节点释放锁后，则获取锁；
若本进程为写请求，则向比自己序号小的最后一个读请求节点注册 watch 监听，当
监听到该节点释放锁后，获取锁。

zk 解决分布式锁单点故障、不可重入、死锁等问题，不过因为频繁的创建临时顺序节点，性能比缓存实现的分布式锁差。

不过 zk 由于解决了分布式锁的大多数问题，并且也没有数据库和缓存的众多问题，实现起来也比较方便，各大框架都已经封装好了对 zk 的使用，所以**分布式锁的首选就是 zookeeper。**

## 分布式锁 go 语言实践

通常在具体实践中，我们会使用中间件去实现分布式锁，比如 zookeeper、redis、etcd 等等。下面讲解一下使用 go 语言去调用该中间件的 go driver 去实现的具体分布式锁的方法。

### redis

### zookeeper

### etcd

## 参考资料

- https://mp.weixin.qq.com/s/FsOkz265kFMh_fuQZYDlvA








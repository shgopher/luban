<!--
 * @Author: shgopher shgopher@gmail.com
 * @Date: 2025-04-16 16:26:32
 * @LastEditors: shgopher shgopher@gmail.com
 * @LastEditTime: 2025-07-20 17:59:23
 * @FilePath: /luban/系统设计基础/分布式/分布式组件/分布式事务/README.md
 * @Description: 
 * 
 * Copyright (c) 2025 by shgopher, All Rights Reserved. 
-->
# 分布式事务
## 事务的基本概念
所谓事务指的就是要么事件成功，要么失败，所有的中间状态都不能存在，即不能存在成功一半的情况。分布式事务是众多本地事务组成的。

那么我们再重温一下单机事务的 ACID 属性：
- 原子性：即事务的结果是原子性的，只有两个结果，要么成功，要么失败。
- **一致性**：事务操作前后，数据的完整性保持一致或满足完整性约束，比如两个人转钱，那么钱的总数必定是不变的。
- 隔离性：两个不同的事务之间不能相互干扰，任何事务之间的操作都不能干扰到其它事务的执行结果。
- 持久性：事务执行之后是持久的，该记录被永远保存不能丢失。

不过，分布式事务中，一致性并不能完全实现，我们使用 BASE 理论之后强一致性就会转化为最终一致性或者弱一致性。这是因为在分布式的环境中，数据众多，要想实现强一致性势必影响整体的性能。
## 使用 go 语言的中间件 gorm 去实现一个事务
## 在 clean 架构中去使用事务
## 分布式事务的具体实践
分布式事务的主要分类是下面三种

- ​​ 强一致性协议 paxos，raft​​：(代价：牺牲可用性 A 保留一致性 C；CAP 定理中的 C 与 A 冲突)
  - 两阶段提交 (2PC) ​​：通过协调者与参与者协作，分 “准备-提交” 两阶段实现原子性。
  - 三阶段提交 (3PC) ​​：在 2PC 基础上增加超时机制，降低阻塞风险。

- ​ 最终一致性模型 ​​：(优势：提升系统可用性，但需容忍短暂不一致)
  - ​ 补偿事务 (Saga) ​​：通过逆向操作回滚已完成的子事务，例如订单取消后自动退款。
  - ​ 异步消息队列 ​​：利用消息中间件 (如 Kafka) 保证操作最终执行，适用于高吞吐场景。
  
- 混合方案 ​​：
  - TCC 模式 (Try-Confirm-Cancel) ​​：通过预留资源、确认执行、取消补偿三个阶段平衡一致性与性能。
  - 分布式锁 ​​：在并发场景下通过锁机制保证隔离性，如 Redis 分布式锁
## 参考资料
- https://xqey620khg.feishu.cn/docx/RAPmde56Pojc4QxgLrtc1Ga7noe?from=from_copylink
- https://mp.weixin.qq.com/s/0Io-X0S9AY-s0HeRb_jbag


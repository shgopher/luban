<!--
 * @Author: shgopher shgopher@gmail.com
 * @Date: 2025-04-16 21:20:24
 * @LastEditors: shgopher shgopher@gmail.com
 * @LastEditTime: 2025-05-18 10:46:18
 * @FilePath: /luban/系统设计基础/分布式/分布式关键技术/分布式技术概论/README.md
 * @Description: 
 * 
 * Copyright (c) 2025 by shgopher, All Rights Reserved. 
-->
# 分布式技术概论

首先，我们要讨论一下为什么要从单体架构改到分布式架构 --- 我们需要增加系统的负载容量，提高系统的可用性消除单点故障。

除此之外，分布式架构还可以加快开发进度，增加模块化进行提高部件的重用度，整个系统的可扩展性也大大提高，并且对于整个团队的协作流程也会有一个显著的提升。

看一下单体架构和分布式架构的优缺点对比：

| 对比项         | 传统单体架构                     | 分布式服务化架构                     |
|----------------|----------------------------------|--------------------------------------|
| 新功能开发     | 需时间                           | 容易开发和实现                       |
| 部署           | 不常且易部署                     | 常发布，部署复杂                     |
| 隔离性         | 故障影响范围大                   | 故障影响范围小                       |
| 架构设计       | 难度小                           | 难度级数增加                         |
| 系统性能       | 响应时间快，吞吐量小             | 响应时间慢，吞吐量大                 |
| 系统运维       | 运维简单                         | 运维复杂                             |
| 新人上手       | 学习曲线大（应用逻辑）           | 学习曲线大（架构逻辑）               |
| 技术           | 技术单一且封闭                   | 技术多样且开放                       |
| 测试和查错     | 简单                             | 复杂                                 |
| 系统扩展性     | 扩展性很差                       | 扩展性很好                           |
| 系统管理       | 重点在于开发成本                 | 重点在于服务治理和调度               |

下面我们要讨论一下分布式技术中的一些技术难点。

首先就是架构设计变得更加复杂，毕竟单体架构中基本上不存在什么模块，也就不存在什么架构设计的问题；系统的吞吐量是加大了，但是系统的响应时间是增加了，也就是变慢了，很容易理解，因为从之前的单体服务到分布式架构，一个访问从一次网络请求变成了多次网络请求，所以自然响应时间会增加；运维会更加复杂；学习曲线也会更加难；整个系统的测试难度会增加，毕竟跨越服务的测试要比单体架构的同一个系统环境上下文下的测试要难的多；服务和调度更加复杂，也就是所谓的服务治理的难度会增加，毕竟分布式架构中，各个服务之间已经不属于内网概念，需要加强安全鉴别，需要增加监控，需要增加各个服务之间的治理，调节，管控的操作。

那么，一个现代分布式架构，通常我们描述的就是微服务架构，它都需要什么技术呢？大体上需要两个，**首先就是提供例如服务注册中心，服务发现，服务治理，服务监控，配置中心等基础分布式基础设施的微服务框架 (例如 Spring Cloud，kratos 等)，第二就是一个服务部署，编排基础设施 (例如 k8s 和 istio)**

下面我们讨论一下分布式技术架构的基本技术栈。

注意，分布式架构的出现基本上是围绕着两项需求来的，一就是如何容纳更多的吞吐量，如何通过集群技术将大规模请求负载均衡到不同的服务商 --- **也就是高性能**；第二就是如何保证关键技术的可用性，提高后台的可用性，减少联动故障，或者在出现 bug 时如何降级的提供服务 --- **也就是高可用性**。

首先让我们讨论一下**高性能**相关的技术栈。

- 缓存，缓存技术是快速提高访问能力的**最有效的手段**，比如前端的浏览器缓存，网络缓存，服务端的各种缓存，数据库的缓存等等，在分布式系统中，通常我们需要一个缓存的集群，并且需要一个 proxy 去进行缓存的路由和分片。
- 负载均衡，**负载均衡是水平扩展的关键技术**，它让众多机器去共同负载一部分请求，从而提高系统的吞吐量。
- 异步调用，**核心是通过消息队列将请求做排队处理**，可以削峰客户端的请求压力，服务端通过自己的处理速度慢慢处理这些在队列中的数据，通过时间换空间的方法可以提高系统的吞吐量，但是实时性变差，并且很可能会出现消息丢失的情况 (针对这一点要引入消息持久化来解决，不过这样会造成有状态的节点，从而增加系统调度的复杂度)
- 数据分区和数据镜像，数据分区就是根据数据的某些特征，比如地区，来讲数据分配于不同的数据库中，这需要一个数据库中间件来处理这个需求，同时跨数据库的操作也将带来一定的难度；数据镜像就是同一个数据复制在不同的数据库中，系统可以自动的进行数据的同步，不过这将会引入数据一致性的问题。对数据库的处理还有两个常见的优化方法，读写分离和分库分表，读写分离就是将读请求和写请求分开到不同的数据库中，分库分表就是将数据根据某些特征进行分库或者分表，这样可以提高数据库的性能。

下面是一些**高可用**相关的技术栈：
- 服务拆分，服务拆分的目的首先是为了隔离故障，其次也可以进行服务的复用，不过缺点就是会引入服务调度之间的依赖。
- 服务冗余，服务冗余的目的是为了消除单点故障，并且支持服务的弹性扩容，以及故障迁移，不过对于有状态的服务来说，冗余这些状态会带来很大的复杂度，比如弹性扩容时要考虑数据的复制，以及重新分片问题，迁移的时候也要将状态迁移到其它机器上。
- 限流降级，当系统扛不住巨大的流量时，需要将流量进行限流拒绝一定的客户请求，或者将一些不重要的请求进行降级处理，这样可以保证系统不会挂掉，这属于保护性的措施。
- 高可用架构，高可用架构从冗余的角度来设计架构，比如多租户隔离，灾备多活，数据保证一致性的集群等。核心是不出现单点故障。
- 高可用运维，通常高可用的运维就是通过 DevOps 来实现的，CI/CD (持续集成，持续部署)，自动化测试，灰度发布，蓝绿发布，金丝雀发布等都是高可用运维的手段。

## 分布式系统的关键技术
- 服务治理，服务拆分、服务调用、服务发现、服务依赖、服务的关键度定义，服务治理就是把服务间的依赖关系、服务调用链，以及关键的服务给梳理出来，并对这些服务进行性能和可用性方面的管理
- 流量控制，负载均衡、服务路由、熔断、降级、限流等和流量相关的调度都会在这里，包括灰度发布之类的功能也在这里。
- 架构软件管理，服务之间有依赖，而且有兼容性问题，所以，整体服务所形成的架构需要有架构版本管理、整体架构的生命周期管理，以及对服务的编排、聚合、事务处理等服务调度功能。
- DevOps，环境构建、持续集成、持续部署、自动化测试、自动化发布、自动化监控等，DevOps 就是将开发和运维进行结合，形成一个完整的闭环。
- 自动化运维，有了 DevOps 后，我们就可以对服务进行自动伸缩、故障迁移、配置管理、状态管理等一系列的自动化运维技术了。
- 资源调度管理，
- 架构监控
## 分布式系统的核心纲领

|全栈监控|资源，服务调度|数据调度|流量调度|
|---|---|---|---|
|基础层监控（os，主机，网络），中间层监控（消息队列，缓存，数据库，网关，RPC服务等），应用层监控（API请求，吞吐量，函数关系调用栈，调用链路等）|计算资源调度（CPU ，内存，磁盘，网络），服务调度（服务编排，服务伸缩，故障迁移，服务生命周期管理），架构调度（多租户，架构版本控制，架构部署运行更新销毁，灰度发布）|数据可用性（多副本），数据一致性（读写一致性），数据分布式（数据索引分片）|服务治理（服务发现，服务路由，服务降级，服务熔断，服务保护），流量控制（负载均衡，流量分配，流量控制，异地容灾），流量管理（数据缓存，协议转换，请求校验，数据计算）|
<!--
 * @Author: shgopher shgopher@gmail.com
 * @Date: 2024-11-27 16:20:37
 * @LastEditors: shgopher shgopher@gmail.com
 * @LastEditTime: 2024-12-02 00:21:52
 * @FilePath: /luban/系统设计基础/分布式/分布式关键技术/流量治理/README.md
 * @Description: 
 * 
 * Copyright (c) 2024 by shgopher, All Rights Reserved. 
-->
# 流量治理
## 服务容错
**容错处理**是微服务架构中的一个重要原则，因为如果不处理容错，该错误可能会传导到系统的各处，导致整个系统都不可用，发生错误雪崩是一个应该极力避免的事情。

### 容错策略
除了时刻意识到错误的出现，还得掌握一定的容错策略：
- **1 故障转移**，高可用系统中，一个服务往往会部署多个副本节点，为了避免故障，不同的副本节点往往部署在不同的交换机，甚至不同的区域，不同的数据中心。故障转移就是，**当请求的服务出现故障时，不会立刻返回错误，而是将请求转发到其他节点，从而实现服务的高可用。**故障转移应该设置为**有限的**请求次数，因为一旦无限制的故障重试就可能造成整个调用链路的各个阶段的失败，就跟你买的火车票连续转车一样，第一站如果错过了，后续的所有转车都会失败。

- **2 快速失败**，对于不能进行故障转移的，比如并**没有配置幂等性的**服务，如果你重复的进行调用就会产生脏数据，所以直接选择快速失败即可，比如银行付款，绝对不能选择重试，对于付款失败的行为，立刻马上返回错误！！

- **3 安全失败**，当系统的某些**非重要组件失败时**，系统自动忽略，**即便是失败也返回正常的相应**，不过返回的值是一个设定的空值，这是因为某些组件并不会产生传播效应，它失败了并没有对系统本身产生影响，例如说日志系统，例如读取数据库的内容，但是不会对数据库本身，以及整个业务产生任何的影响，仅仅把读取的数据用作统计结果，诸如此类的服务都可以使用安全失败的方法。

- **4 沉默失败**，当**某个请求失败时**，就默认该组件失效，**短时间内不再向它发起重试**，比如大量的请求需要等到超时才宣布失败，就会对系统操作例如内存泄露，服务器宕机等后果，所以这个策略就是当某个请求失败时，直接默认它死了，不要再堆积同样的访问导致整个系统大受影响，这也是一种**隔绝错误的方法**

- **5 故障恢复**，**一般跟快速失败结合一起用**，当某个访问错误时，立刻快速失败，但是把该失败操作放入一个消息队列中由系统异步开始故障恢复的重启操作。服务必须具有幂等性，由于它的重试是后台异步进行，即使最后调用成功了，原来的请求也早已经响应完毕，所以故障恢复策略一般用于实时性要求不高的主路，或者处理那些不需要返回值的旁路。为了避免内存溢出，故障恢复次数要有限制。

- **6 并行调用**，下面这两个跟上面的错误处理机制不同，这是两种正常操作的为了最大效率的策略机制，一开始就对于同一个服务进行多次并行调用，哪个成功了就直接返回成功的结果，其它的访问立刻停止，

- **7 广播调用**，这个跟并发调用很像，也是多个操作对一个服务进行请求，不过不同的是，并行调用是一个操作成功就宣布成功，而广播调用是要把结果广播给全部的并行操作，这个跟 go 语言并发库 singleflight 原理一致，多个请求只要有一个请求成功，那么就返回成功，并且把结果广播给全部的请求。

|容错策略|优点|缺点|使用场景|
|:---:|:---:|:---:|:---:|
|故障转移|系统自动处理，调用者对于失败不可见|增加调用时间，额外的系统开销|要求**必须幂等**，以及对于**调用时间不敏感**的服务|
|快速失败|调用者有对失败的处理完全控制权，不依赖服务的幂等性|调用者必须正确处理失败逻辑，如果一味只是对外抛异常，**容易引起服务雪崩**|调用**非幂等**的服务或者**超时阈值较低**的场景|
|安全失败|不影响主路逻辑|只适用于旁路调用|调用链中的旁路服务|
|沉默失败|控制错误不影响全局|出错的地方将在一段时间内不可用|频繁超时的服务|
|故障恢复|调用失败后自动重试，也不影响主路逻辑|重试任务可能产生堆积，重试仍然可能失败|调用链中的旁路服务**对实时性要求不高**的主路逻辑也可以使用|
|并行调用|尽可能在**最短时间内获得最高的成功率**|额外消耗机器资源，大部分调用可能都是无用功|资源充足且对失败容忍度低的场景|
|广播调用|支持同时对批量的服务提供者发起调用|资源消耗大，失败概率高|只适用于**批量操作**的场景|
### 容错设计模式
**断路器模式**

通过代理，也就是断路器来一对一的接管服务调用者的远程请求，一个远程服务对应一个断路器的对象，断路器会持续监控并且统计服务返回的成功，失败，超时，拒绝等结果。



当故障次数达到断路器的阈值时，它的状态就自动变成 “OPEN” (也就是断路器**打开状态**，打开就证明**断掉**了，不能再访问远程服务了)，后续次断路器代理的远程访问都将直接返回调用失败的结果，看出来了把，这就是**快速失败策略**

说白了，断路器就是一个代理，它本身就是一个有限状态机，比如它可以有 `OPEN，HALF-OPEN，CLOSED` 等状态。有没有发现其实跟 sidecar 一样也是一个代理，通过这种代理的方法去处理，可以在代理身份放置多种处理手段，还不用干涉核心的代码逻辑。

- CLOSED：正常状态，可以正常访问服务。

- HALF-OPEN：这是一种中间状态。**断路器必须带有自动的故障恢复能力**，当进入 OPEN 状态一段时间以后，将自动 (一般是由下一次请求而不是计时器触发的) 切换到 HALF OPEN 状态。该状态下，会放行一次远程调用，然后根据这次调用的结果成功与否，转换为 CLOSED 或者 OPEN 状态，以实现断路器的弹性恢复。

- OPEN：打开状态，**不能访问服务**，直接实现**快速失败的策略**


从 CLOSED 状态转化为 OPEN 状态的基本条件：

- 一段时间内，比如10秒，请求数量达到阈值
- 一段时间内，请求的故障达到阈值

断路器模式其实就是一种实现了微服务中的服务熔断操作，自动实现服务熔断，实现快速失败的容错策略，目前为止都是服务熔断的操作，那么如果当这个错误上报给系统之后，上游的服务主动的处理调用失败的后果，而不是让故障扩散，这里的处理就是服务降级，比如，我们的降级操作是把这个服务记录下来，等待之后重新处理，这个过程就是降级了。

所以服务先熔断，然后再降级处理。


**舱壁隔离模式**



**重试模式**

****

## 流量控制

微服务的分布式架构中，即便是没有遇到雪蹦式的错误，**面临超过预期的突发请求时，大部分请求直至超时都无法完成处理，所以我们就需要流量控制**，即对请求进行限流，防止请求过多，系统崩溃。
(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{547:function(t,v,_){"use strict";_.r(v);var i=_(36),s=Object(i.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"分布式中的缓存"}},[t._v("分布式中的缓存")]),t._v(" "),_("p",[_("strong",[t._v("缓存是一个典型的空间换时间的优化手段")]),t._v("，对于软件角度的缓存，往往缺点大于优点，看似带来了一定的性能提升，但是随之而来的负面作用往往不可忽视，引入缓存，你要处理数据一致性问题，缓存的失效，更新等等各种问题，极大的增加了系统整体复杂度，从运维的角度来说，缓存的存在也掩盖了 bug，让 bug 出现在更久之后，距离真实现场更远的地方，从安全的角度来说，缓存也可能会泄露保密数据，但是，我要说但是，缓存的引入将带来极大的性能提升，不管是 cpu 还是 io 的角度。")]),t._v(" "),_("p",[t._v("从 cpu 的角度来说，本身要进行的复杂计算，使用缓存将数据存储起来，无需重复计算，从 io 的角度来说，从缓存去读取数据要远比从磁盘上的数据库读取数据快的多")]),t._v(" "),_("p",[t._v("缓存虽然是空间换时间的方法，但是缓存本身是用来缓解 cpu 和 io 的压力而生的，"),_("strong",[t._v("它的目的并不是直接的提升性能")]),t._v("，因为你完全可以直接升级 cpu 和 io 的性能，这样又不会引入那么多的缺陷不是吗？")]),t._v(" "),_("h2",{attrs:{id:"缓存的属性"}},[t._v("缓存的属性")]),t._v(" "),_("ul",[_("li",[t._v("吞吐量，读写操作的效率，使用 OPS (每秒的操作量) 来进行衡量，吞吐量越高越好")]),t._v(" "),_("li",[t._v("命中率，成功从缓存中返回的结果和总请求次数的比值，命中率越高越好")]),t._v(" "),_("li",[t._v("扩展功能，除了基本读写之外的扩展功能，比如，最大容量，失效时间，失效事件，命中率统计")]),t._v(" "),_("li",[t._v("是否支持分布式，缓存有进程缓存分布式缓存两大类，前者仅仅为本身节点提供服务，比如你在读写过程中引入了一个数组，或者哈希表，不需要反复读取磁盘，仅需要读取本地数据或者哈希表中的缓存即可获取数据，这种缓存并无网络操作，速度很快，但是缓存的数据不能在各个节点中共享，分布式缓存则相反，它存在于多个独立的缓存节点组成的集群中，这些节点可以分布于不同的数据中心，分布式缓存可以被不同的应用进程所共享，各个组件之间可以很方便的获取相同的缓存数据。")])]),t._v(" "),_("h3",{attrs:{id:"吞吐量"}},[t._v("吞吐量")]),t._v(" "),_("h3",{attrs:{id:"命中率"}},[t._v("命中率")]),t._v(" "),_("h3",{attrs:{id:"扩展功能"}},[t._v("扩展功能")]),t._v(" "),_("h3",{attrs:{id:"分布式支持"}},[t._v("分布式支持")]),t._v(" "),_("h2",{attrs:{id:"缓存的风险"}},[t._v("缓存的风险")]),t._v(" "),_("h3",{attrs:{id:"缓存穿透"}},[t._v("缓存穿透")]),t._v(" "),_("h3",{attrs:{id:"缓存击穿"}},[t._v("缓存击穿")]),t._v(" "),_("h3",{attrs:{id:"缓存雪崩"}},[t._v("缓存雪崩")]),t._v(" "),_("h3",{attrs:{id:"缓存污染"}},[t._v("缓存污染")])])}),[],!1,null,null,null);v.default=s.exports}}]);